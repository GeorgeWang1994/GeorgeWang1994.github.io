
# Django迁移主键总结

## 背景



因为当前项目中的表中使用了非常多的外键来关联表，这就会导致当更新主表的`id`的时候，导致所有相关联的表全部都要更新，至于为什么会更新`id`，我认为是当初设计表的人没有理解这个表的含义，对于表中的一个实例数据，它代表的就是特定的一个东西，而这个东西的`id`不应该是会去改变的，但是它是和Docker中的`container_id`去绑定的，而Docker在重启的时候就会重新分配`container_id`，而如果想把其他关联的数据都要和之前一样，就不得不去更新相关联的表的外键id，并且如果这些关联的数据量如果巨大，更新就变成一个非常不划算的操作，因此我想到了重新设计表，具体的原因如下：



1. 关联表数据量大，更新操作耗费时间，即使放进任务队列中，但是期间如果新增的关联数据还是之前的id，那么问题就会变得比较复杂；
2. 表的设计不合理，应该维护`container_id`，而不是以可变的`container_id`作为主键，这样就可以不用去更改其他关联表的外键；



## 相关表&需求



以下是之前的表的设计：

```python
from django.db import models


class HP(models.Model):
    id = models.CharField(max_length=20, unique=True, null=False, blank=False)
    name = models.CharField(max_length=20, default="")


class AG(models.Model):
    id = models.CharField(max_length=20, primary_key=True)
    name = models.CharField(max_length=20, default="")
    hps = models.ManyToManyField(HP, related_name='ags', blank=True)


class CN(models.Model):
    id = models.CharField(max_length=20, primary_key=True)
    name = models.CharField(max_length=20, default="")
    hp = models.ForeignKey(HP, on_delete=models.SET_NULL, null=True)

```



我们要实现的是增加一个主键的`id`，原来的`id`字段名更改为`cid`，并且数据库中的所有数据不会发生任何的变化。



## 具体的操作



### 🐍. 再造一个表



也就是新增了一张最终想要的表，然后将之前表的数据全部迁移到这张表上去，最后把之前的表的数据给删除掉。



具体的migration操作如下：



```python
# Generated by Django 2.2 on 2019-05-30 11:46

import django
from django.db import migrations, models


def move_hp_data(apps, schema_editor):
    HPModel = apps.get_model("hp", "HP")
    HPTempModel = apps.get_model("hp", "HPTemp")

    hp_qs = HPModel.objects.all()
    for hp in hp_qs:
        HPTempModel.objects.create(
            id=hp.id, cid=hp.id, name=hp.name,
        )


class Migration(migrations.Migration):

    dependencies = [
        ('hp', '0003_auto_20190530_1140'),
    ]

    operations = [
        # 1. 新增表
        migrations.CreateModel(
            name='HPTemp',
            fields=[
                ('id', models.CharField(max_length=20, primary_key=True, verbose_name='ID')),
                ('cid', models.CharField(max_length=20, unique=True)),
                ('name', models.CharField(default='', max_length=20)),
            ],
        ),
        # 2. 迁移表数据
        migrations.RunPython(move_hp_data),
        # 3. 更改关联的外键
        migrations.AlterField(
            model_name='ag',
            name='hps',
            field=models.ManyToManyField(blank=True, related_name='ags', to='hp.HPTemp'),
        ),
        migrations.AlterField(
            model_name='cn',
            name='hp',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to='hp.HPTemp'),
        ),
        # 4. 删除原来的表
        migrations.DeleteModel(
            name='HP',
        ),
        # 5. 重新命名为原先的表
        migrations.RenameModel('HPTemp', 'HP'),
        # 6. 更改关联的外键
        migrations.AlterField(
            model_name='AG',
            name='hps',
            field=models.ManyToManyField(blank=True, related_name='ags', to='hp.HP'),
        ),
        migrations.AlterField(
            model_name='CN',
            name='hp',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to='hp.HP'),
        ),
    ]
```



执行`makemigration`后可以发现，会显示没有什么可以改变的，接着进行`migrate`操作，发现数据库也没有发生任何的变化，成功！！



如果它们分别散布在不同的app当中，那么就需要注意执行的顺序，需要改动到`dependencies`中的文件，最后在makemigrations的时候需要注意其互相依赖的顺序。



### 🐱. 在原来表的基础上修改



因为我们增加的这个ID只需要保证唯一性，对于其内容没有什么要求，因此保留原来的主键，新增一个唯一的键去记录变更的容器ID即可，而且这么做还可以保证原先主键关联的所有表的数据都不需要更新，因此这是一种非常简单的方法（具体的实现和上面是类似的）。



但是如果这张表的数量很大，那么拷贝这张表的数据就会变得很吃力，因此如果可以的话，在原来的表的基础上进行新增想要的字段，再将该字段变成为主键，应该怎么半呢？



上面那种方法这种防范比较繁琐，需要改动的东西也比较多。具体可以参考[这里](http://salvalcantara.com/blog/the-motherfucker-migration/#fn:3)

